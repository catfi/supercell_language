SEMANTIC CHECK CHECKLIST

ERRORS:

    E1. UNDEFINED NAME (V)
        a. NO SUCH NAME
        b. NO IMPL BODY
    E2. NAME COLLISION
        a. DUPLICATE DEFINE/DECLARE (J) (S0)
        b. AMBIGUOUS REFERENCE (V)
    E3. INCOMPATIBLE TYPE
        a. CAST FAIL (SDK)
            I.   EXPRESSION WITH INVALID OPERANDS (INCL. ASSIGN FAIL) (SDK)
            II.  STATEMENT WITH INVALID ARGUMENTS (INCL. NON-BOOL USED AS CONDITION) (SDK)
            III. DECLARATION WITH INVALID ARGUMENTS (SDK)
        b. NON-EXIST SUBSCRIPT (J) (S1)
        c. FUNCTION
            I.   CALL NON-FUNCTION (J) (S1)
            II.  CALL FUNCTION WITH WRONG ARGUMENT COUNT (J) (S1)
            III. RETURN STATEMENT WITH WRONG ARGUMENT COUNT/TYPE (INCL. MISSING RETURN STATEMENT) (J) (S1)
    E4. MODIFIER POLICY VIOLATION
        a. STORAGE VIOLATION
            I.  ASSIGN NON-CONST EXPRESSION TO CONST
            II. STATIC-RELATED
                i.  CALL NON-STATIC FUNCTION WITHOUT INSTANCE (J) (S1)
                ii. NON-STATIC VAR ACCESSED IN STATIC FUNCTION (J) (S1)
        b. VISIBILITY VIOLATION (J) (S1)
    E5. BREAK/CONTINUE NOT INSIDE ITERATION (J) (S0)
    E6. VARIABLE
        a. GLOBAL/MEMBER INITIALIZATION LIST EXPRESSION SHOULD BE CONST (J) (S1)
        b. PARAMETER
            I.  NON-OPTIONAL PARAMETER CANNOT APPEAR AFTER OPTIONAL PARAMETER (J) (S0)
            II. VARIADIC PARAMETER NOT LAST PARAMETER (J) (S0)
    E7. LANGUAGE LIMIT VIOLATION
    	a. FUNCTION CALL PARAMETER COUNT LIMIT (J) (S0)
    	b. TEMPLATE PARAMETER COUNT LIMIT (EITHER DECLARATION OR SPECIALIZATION) (J) (S0)

WARNINGS:

    W1. USING UNINITIALIZED VAR (J) (S2)
    W2. CODE PATH
        a. UNUSED DEFINE/DECLARE (J) (S2)
        b. DEAD CODE NEVER EXECUTES (NOTE: ALWAYS BRANCH BEFORE THIS LINE) (J) (S0)
        c. NOT ALL CODE PATHS RETURN A VALUE (J) (S0)
        d. CODE EXECUTES, BUT HAS NO USEFUL EFFECT (J) (S2)
        e. NOT ALL ENUM VALUES COVERED BY SWITCH CASES (INCL. MISSING DEFAULT) (J) (S1)
    W3. RECURSIVE CALL ALWAYS REACHABLE FROM FUNCTION START (J) (S?)

MESSAGES:

    E1.a:       ‘ID’ was not declared in this scope
    E1.b:       undefined reference to `ID'
    E2.a:       error: redeclaration/redefinition of ‘ID’
                error: ‘ID’ previously declared here <<< additional message >>>
    E2.b:       <<< no c++ equivalence >>>
    E3.a.I:     error: invalid conversion from ‘ID’ to ‘ID2’
                error: no matching function for call to ‘ID’
                note: candidates are: ID <<< additional message >>>
    E3.a.II:    error: could not convert ‘ID’ to ‘bool’
    E3.a.III:   <<< no c++ equivalence >>>
    E3.b:       error: request for member ‘ID’ in ‘ID2’, which is of non-class type ‘ID3’
    E3.c.I:     error: ‘ID’ cannot be used as a function
    E3.c.II:    error: too many/few arguments to function ‘ID’
    E3.c.III:   error: return-statement with a value, in function returning 'void'
                error: return-statement with no value, in function returning ‘ID’
                warning: no return statement in function returning non-void <<< additional message, may be stand-alone >>>
    E4.a.I:     error: uninitialized const ‘ID’
                error: assignment of read-only variable ‘ID’
    E4.a.II.i:  error: cannot call member function ‘ID’ without object
    E4.a.II.ii: error: invalid use of member ‘ID’ in static member function
                error: from this location <<< additional message >>>
    E4.b:       error: ‘ID’ is private/protected
                error: within this context
    E5:         error: break statement not within loop or switch
                error: continue statement not within a loop
    E6.a:       <<< no c++ equivalence >>>
    E6.b.I:     error: default argument missing for parameter #NUM of ‘ID’
    E6.b.II:    <<< syntax-error in gcc >>>
    E7:         <<< no c++ equivalence >>>

    W1:         warning: ‘ID’ is used uninitialized in this function
    W2.a:       In function ‘ID’: <<< additional message >>>
                warning: unused variable ‘ID2’
    W2.b:       <<< no c++ equivalence >>>
    W2.c:       warning: control reaches end of non-void function
    W2.d:       warning: unused variable ‘x’
    W2.e:       warning: enumeration value ‘ID’ not handled in switch
    W3:         <<< no c++ equivalence >>>

/////////////////////////////////////////////////////////////////////
/// BASIC
/////////////////////////////////////////////////////////////////////

// templated identifier
    (E2.a) - No parameter name conflict is allowed
    () - The "..." type is only allowed once at the end of template parameter list
    (E1) - The "..." type is not allowed when the AST is processed and transformed. It should be expanded.
    (E7) - There should be a limit on the many templated parameters allowed in a single templated identifier

// annotations
    () - If there's no custom annotation..

/////////////////////////////////////////////////////////////////////
/// EXPRESSION
/////////////////////////////////////////////////////////////////////

// unary expression
    (E3.a.I) - Check whether the type can be applied with specific unary operation (for example, ~ or ! cannot be used with floating number)

// binary expression 
    (E3.a.I) - Check the type compatibility between LHS and RHS
    (E1) - All expression must be fully resolved

// ternary expression
    (E3.a.I) - Check the type compatibility between LHS and RHS

// call expression
    (E3.a.I) - Check whether the node is callable
    (E4.a.II.i) - If the callee is a MemberExpr and the RHS is resolved to a non-static member function, we need to check if the LHS is a variable of that instance

// cast expression
    (E3.a) - Check whether the node is convertible to the desired type

/////////////////////////////////////////////////////////////////////
/// STATEMENT
/////////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////////
    /// SELECTION STATEMENT
    /////////////////////////////////////////////////////////////////////

    // if/elseif/else statement
        (E3.a.II) - The both if and elseif Selection must have non-null condition
        (E3.a.I) - The condition expression must be able to cast into a boolean variable (and insert cast operation when necessary)

    // switch statement
        (W2.e) - If the condition is a variable resolved to EnumDecl type, all cases must be covered or there's default case, otherwise generate a warning for it

    /////////////////////////////////////////////////////////////////////
    /// ITERATION STATEMENT
    /////////////////////////////////////////////////////////////////////

    // while/dowhile statement
        (W1.a) - If the condition can be evaluated as constant expression and its value is always true and there's no break in the while/do-while block, generate infinite loop warning

    // foreach statement
        (E3.a.II) - The range expression must be an instance of Range<T> type
        (E3.a.II) - The iterator must be a variable declaration or a primary expression resolved to a symbol

/////////////////////////////////////////////////////////////////////
/// DECLARATION
/////////////////////////////////////////////////////////////////////

// global variable declaration
    () - The initializer must be constant expression (or can be deduced as constant expression)

// local variable declaration
    (E4.a.I.i) - The constant variable cannot be modified once it's set in the initializer

// function declaration
    (W2.c) - If the function has non-void return type, check if all paths have return value (and are of the same type)
    (E3.a.III) - If the function has void return type, then there's no return (BranchStmt) allowed in the tree

// class declaration
    (E2.a) - The class name cannot conflict with other class (name resolving conflict)
    (E3.a.III) - The identifiers for interface implementation must refer to an interface
    (E2.a) - There can be more than one new function (constructor overload) as long as they have different parameter signature
    (E7) - There should be a limit on how many member variables allowed in a single class

// class member variable declaration
    (E2.a) - The variable name must not conflict with the class name or member function name
    (E2.a) - The variable names must not conflict with each other

// typedef declaration
    (E3.a.III) - The "from" node must refer to a type, and the "to" node must be an simple identifier

// enum declaration
    (E2.a) - The identifiers must not conflict with each other
    () - The initialization list must be constant (just like global variable) and of integral type

// interface declaration
    (E4.b) - All methods in interface should not have "private" member scope specifier
    (PARSER) - All methods in interface should have no function body
    (E1) - All types must be explicitly specified for member function in interface

// class/interface member function declaration
    (E1) - The function parameters must be fully resolved
    () - Except member function in interface, function must have body block (local anonymous function must be renamed beforehand)
    (E2.a) - The function name cannot conflict with other function unless they have different parameter signature (name resolving conflict)
    (E7) - There should be a limit on the many parameters allowed in a single function

/////////////////////////////////////////////////////////////////////
/// MODULE
/////////////////////////////////////////////////////////////////////

// package
    (E2.a) - The package name should not conflict with its parent and sibling
