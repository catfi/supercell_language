/**
 * Zillians MMO
 * Copyright (C) 2007-2011 Zillians.com, Inc.
 * For more information see http://www.zillians.com
 *
 * Zillians MMO is the library and runtime for massive multiplayer online game
 * development in utility computing model, which runs as a service for every
 * developer to build their virtual world running on our GPU-assisted machines.
 *
 * This is a close source library intended to be used solely within Zillians.com
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ZILLIANS_LANGUAGE_STRINGTABLE_H_
#define ZILLIANS_LANGUAGE_STRINGTABLE_H_

#include "core/Prerequisite.h"
#include "utility/StringUtil.h"
#include "utility/UnicodeUtil.h"
#include "language/tree/ASTNode.h"
#include "language/logging/LoggerWrapper.h"
#include "language/context/LogInfoContext.h"
#include "language/stage/parser/context/SourceInfoContext.h"
#include <boost/parameter.hpp>
#include <vector>
#include <string>
#include <sstream>
#include <map>

using namespace std;

namespace zillians { namespace language {


/**
 * StringTable is a data center for log messages, and it provides:
 *
 * 1. Tables of attributes for each message
 * 2. Translation for each message
 *
 */
struct StringTable
{
	/*[[[cog

	class Repo:
		""" Helper class to create attributes on the fly """
		def __init__(self):
			self.repo = []

		def create(self, name):
			if hasattr(self, name):
				raise AttributeError, 'Attribute %s Already Exist' % name
			setattr(self, name, name)
			self.repo.append(getattr(self, name))

	class LogRepo(Repo):
		def __init__(self):
			Repo.__init__(self)
			self.attribute_table = {}
			self.translation_table = {}

		def create(self, name, level, warn_level, trans):
			Repo.create(self, name)
			log_id = getattr(self, name)
			self.attribute_table[log_id] = (level, warn_level, log_id)
			self.translation_table[log_id] = trans


	#################################################################
	# BEGIN MANUAL EDIT SOURCE
	#################################################################

	# Define log level
	LOG_LEVEL = Repo()
	LOG_LEVEL.create('LEVEL_INFO')
	LOG_LEVEL.create('LEVEL_WARNING')
	LOG_LEVEL.create('LEVEL_ERROR')
	LOG_LEVEL.create('LEVEL_FATAL')

	# Define constant string
	LOG_STRING = LogRepo()
	############################################# EXAMPLE
	LOG_STRING.create('EXAMPLE_UNUSED_VARIABLE', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'Undefined variable $ID(string) is used, $ID(string) should not be used',
			zh_TW = '$ID(string) 未被使用，$ID(string) 不應該被用'
			))
	LOG_STRING.create('EXAMPLE_UNDEFINED_VARIABLE', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'Undefined variable $ID(string) in $FILE(string) in $LINE(uint32)',
			zh_TW = '變數 $ID(string) 在 $FILE(string) 中第 $LINE(uint32) 行未被定義'
			))
	############################################# PARSER_STAGE
	############################################# STATIC_TEST_VERIFICATION_STAGE
	LOG_STRING.create('WRONG_STATIC_TEST_ANNOTATION_FORMAT', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'Wrong static test annotation format: $DETAIL(string)',
			zh_TW = '錯誤的 static test annotation 格式: $DETAIL(string)'
			))
	############################################# TRANSFORMER_STAGE
	LOG_STRING.create('NUMERIC_LITERAL_OVERFLOW', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'the given numeric literal is overflowed',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> NUMERIC_LITERAL_OVERFLOW'
			))
	############################################# SEMANTIC_VERIFICATION_STAGE (ERRORS)
	LOG_STRING.create('UNKNOWN_NAME', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = '$ID(string) was not declared in this scope',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> LOG_UNKNOWN_NAME'
			))
	LOG_STRING.create('UNDEFINED_REF', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'undefined reference to $ID(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> UNDEFINED_REF'
			))
	LOG_STRING.create('DUPE_NAME', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'redeclaration/redefinition of $ID(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> DUPE_NAME'
			))
	LOG_STRING.create('AMBIGUOUS_REF', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'NOTE: lacking message for ==> AMBIGUOUS_REF',
			zh_TW = 'NOTE: 暫無中文翻譯 ==>  AMBIGUOUS_REF'
			))
	LOG_STRING.create('WRITE_RVALUE', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'lvalue required as left operand of assignment',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> WRITE_RVALUE'
			))
	LOG_STRING.create('INVALID_CONV', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'invalid conversion from $RHS_TYPE(string) to $LHS_TYPE(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INVALID_CONV'
			))
	LOG_STRING.create('NO_MATCHING_MEMBER_FUNC', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'no matching function for call to $FUNC(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> NO_MATCHING_MEMBER_FUNC'
			))
	LOG_STRING.create('INVALID_CONV_BOOL', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'could not convert $TYPE(string) to \'bool\'',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INVALID_CONV_BOOL'
			))
	LOG_STRING.create('MEMBER_OF_NONCLASS', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'request for member $MEMBER_ID(string) in $PRIMARY_ID(string), which is of non-class type $PRIMARY_TYPE(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MEMBER_OF_NONCLASS'
			))
	LOG_STRING.create('NO_SUCH_MEMBER', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = '$PRIMARY_TYPE(string) has no member named $MEMBER_ID(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> NO_SUCH_MEMBER'
			))
	LOG_STRING.create('SUBSCRIPT_OF_NONARRAY', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'invalid types $PRIMARY_TYPE(string) and $SUBSCRIPT_TYPE(string) for array subscript',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> SUBSCRIPT_OF_NONARRAY'
			))
	LOG_STRING.create('CALL_NONFUNC', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = '$FUNC(string) cannot be used as a function',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> CALL_NONFUNC'
			))
	LOG_STRING.create('MISMATCH_CALL_ARGNUM', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'too many/few arguments to function $FUNC(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISMATCH_CALL_ARGNUM'
			))
	LOG_STRING.create('MISMATCH_CALL_ARGTYPE', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'cannot convert $ARG_TYPE(string) to $PARAM_TYPE(string) for argument $ARG_INDEX(uint32) to $FUNC(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISMATCH_CALL_ARGTYPE'
			))
	LOG_STRING.create('UNEXPECTED_RETURN_VALUE', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'return-statement with a value, in function returning \'void\'',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> UNEXPECTED_RETURN_VALUE'
			))
	LOG_STRING.create('MISSING_RETURN_VALUE', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'return-statement with no value, in function returning $TYPE(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_RETURN_VALUE'
			))
	LOG_STRING.create('MISSING_CONST_INIT', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'uninitialized const $VAR(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_CONST_INIT'
			))
	LOG_STRING.create('WRITE_CONST', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'assignment of read-only variable $VAR(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> WRITE_CONST'
			))
	LOG_STRING.create('MISSING_STATIC_INIT', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'NOTE: lacking message for ==> MISSING_STATIC_INIT',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_STATIC_INIT'
			))
	LOG_STRING.create('INVALID_NONSTATIC_CALL', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'cannot call member function $FUNC(string) without object',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INVALID_NONSTATIC_CALL'
			))
	LOG_STRING.create('INVALID_NONSTATIC_REF', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'invalid use of member $VAR(string) in static member function',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INVALID_NONSTATIC_REF'
			))
	LOG_STRING.create('INVALID_ACCESS_PRIVATE', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = '$ID(string) is private',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INVALID_ACCESS_PRIVATE'
			))
	LOG_STRING.create('INVALID_ACCESS_PROTECTED', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = '$ID(string) is protected',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INVALID_ACCESS_PROTECTED'
			))
	LOG_STRING.create('MISSING_BREAK_TARGET', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'break statement not within loop or switch',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_BREAK_TARGET'
			))
	LOG_STRING.create('MISSING_CONTINUE_TARGET', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'continue statement not within a loop',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_CONTINUE_TARGET'
			))
	LOG_STRING.create('MISSING_PARAM_INIT', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'default argument missing for parameter $PARAM_INDEX(uint32) of $FUNC(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_PARAM_INIT'
			))
	LOG_STRING.create('UNEXPECTED_VARIADIC_PARAM', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'NOTE: lacking message for ==> UNEXPECTED_VARIADIC_PARAM',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> UNEXPECTED_VARIADIC_PARAM'
			))
	LOG_STRING.create('UNEXPECTED_VARIADIC_TEMPLATE_PARAM', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'NOTE: lacking message for ==> UNEXPECTED_VARIADIC_TEMPLATE_PARAM',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> UNEXPECTED_VARIADIC_TEMPLATE_PARAM'
			))
	LOG_STRING.create('EXCEED_PARAM_LIMIT', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'NOTE: lacking message for ==> EXCEED_PARAM_LIMIT',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> EXCEED_PARAM_LIMIT'
			))
	LOG_STRING.create('EXCEED_TEMPLATE_PARAM_LIMIT', LOG_LEVEL.LEVEL_ERROR, 0, dict(
			en_US = 'NOTE: lacking message for ==> EXCEED_TEMPLATE_PARAM_LIMIT',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> EXCEED_TEMPLATE_PARAM_LIMIT'
			))
	############################################# SEMANTIC_VERIFICATION_STAGE (WARNINGS)
	LOG_STRING.create('UNINIT_ARG', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = '$VAR(string) is used uninitialized in this function',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> UNINIT_ARG'
			))
	LOG_STRING.create('UNUSED_VAR', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'unused variable $VAR(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> UNUSED_VAR'
			))
	LOG_STRING.create('DEAD_CODE', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'NOTE: lacking message for ==> DEAD_CODE',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> DEAD_CODE'
			))
	LOG_STRING.create('CONTROL_REACHES_END', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'control reaches end of non-void function',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> CONTROL_REACHES_END'
			))
	LOG_STRING.create('MISSING_CASE', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'enumeration value $ENUM_ID(string) not handled in switch',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_CASE'
			))
	LOG_STRING.create('INFINITE_RECURSION', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'NOTE: lacking message for ==> INFINITE_RECURSION',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> INFINITE_RECURSION'
			))
	LOG_STRING.create('MISSING_RETURN', LOG_LEVEL.LEVEL_WARNING, 0, dict(
			en_US = 'no return statement in function returning non-void',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> MISSING_RETURN'
			))
	############################################# SEMANTIC_VERIFICATION_STAGE (HELPERS)
	LOG_STRING.create('PREV_DECL_HERE', LOG_LEVEL.LEVEL_INFO, 0, dict(
			en_US = '$ID(string) previously declared here',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> PREV_DECL_HERE'
			))
	LOG_STRING.create('CANDIDATES_ARE', LOG_LEVEL.LEVEL_INFO, 0, dict(
			en_US = 'note: candidates are: $ID(string)',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> CANDIDATES_ARE'
			))
	LOG_STRING.create('FROM_HERE', LOG_LEVEL.LEVEL_INFO, 0, dict(
			en_US = 'from this location',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> FROM_HERE'
			))
	LOG_STRING.create('IN_FUNCTION', LOG_LEVEL.LEVEL_INFO, 0, dict(
			en_US = 'In function $FUNC(string):',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> IN_FUNCTION'
			))
	LOG_STRING.create('IN_CONTEXT', LOG_LEVEL.LEVEL_INFO, 0, dict(
			en_US = 'within this context',
			zh_TW = 'NOTE: 暫無中文翻譯 ==> IN_CONTEXT'
			))
	#############################################

	#################################################################
	# END MANUAL EDIT SOURCE
	#################################################################

	# Define log string attributes
	attribute_table = LOG_STRING.attribute_table

	# Define translation table
	# Note: the parameter format is $VARIABLE(c++type), and do not have any space in it
	translation_table = LOG_STRING.translation_table

	]]]*/
	//[[[end]]]

	enum log_id {
		/*[[[cog
		import cog

		# Generate all log id
		for i in range(len(LOG_STRING.repo)):
			cog.outl('\t %s,' % LOG_STRING.repo[i]);
		]]]*/
		//[[[end]]]
	};

	enum log_level {
		/*[[[cog

		# Generate all log type
		for i in range(len(LOG_LEVEL.repo)):
			cog.outl('\t %s,' % LOG_LEVEL.repo[i]);
		]]]*/
		//[[[end]]]
	};


	struct attribute_table_t {
		attribute_table_t() {}
		attribute_table_t(log_level level, uint32 degree, log_id id) :
			level(level), degree(degree), id(id) {}
		log_level level;
		uint32 degree;
		log_id id;
	};

	typedef map<string, wstring> locale_translate_map_t;

	// Each message id has its own attributes
	map<log_id, attribute_table_t> attribute_table;

	// Each log id has a translation map, which includes the locale and the specific string mapping
	map<log_id, locale_translate_map_t>  translation_table;


	StringTable()
	{
		/*[[[cog
		# Generate attribute tables
		for (id, attr) in attribute_table.iteritems():
			cog.outl('attribute_table[%s] = attribute_table_t(%s, %d, %s);' % ( (id,) + attr) );

		# Generate string tables for different language
		for (id, locale_trans) in translation_table.iteritems():
			for (locale, trans) in locale_trans.iteritems():
				cog.outl('translation_table[%s]["%s"] = L"%s";' % (id, locale, trans))
		]]]*/
		//[[[end]]]
	}
};

// Default parameters appear in each function
BOOST_PARAMETER_NAME(program_node)
BOOST_PARAMETER_NAME(node)

// Generated parameters appear among all the messages
/*[[[cog
def extract_parameters(trans):
	parameter_hub = {}	# Record appeared parameters
	parameters = []
	splitted = trans.split(' ')
	for word in splitted:
		if word[0] == '$':	# word is like $ID(string)
			var, type = word[1:].split('(')
			if not parameter_hub.has_key(var):
				parameters.append((var, type.split(')')[0]))	# strip out $
				parameter_hub[var] = 1	# the value is no matter
	return parameters

# Examine each translation string (we choose en_US here) and parse the string with dollar sign as
# the parameters

parameter_list = {}	# will store something like, {LOG_UNUSED_VARIABLE: [('FILE', 'string'), ('LINE', 'uint32')]}
all_parameters = {} # use dict feature to record which all the parameters

for (id, locale_trans) in translation_table.iteritems():
	trans = locale_trans['en_US']
	parameter_list[id] = extract_parameters(trans)

	# setup the all parameters
	for (param, type) in parameter_list[id]:
		all_parameters[param] = 1	# the value is no matter

# Generate all the parameters
for param in all_parameters.keys():
	cog.outl('BOOST_PARAMETER_NAME(%s)' % param)

]]]*/
//[[[end]]]


/**
 * Logger initializes each log message as an API
 */
class Logger
{
public:
	Logger() : mWrapper(NULL) {}
	virtual ~Logger() {}

	void setWrapper(LoggerWrapper* logger) { mWrapper = logger; }
	void setLocale(locale& locale) { mLocale = locale; }
	void setStringTable(StringTable* string_table) { mStringTable = string_table; }

public:
	/*[[[cog

	# Generate all functions
	for (id, param_list) in parameter_list.iteritems():
		param_list_string = ''
		for (var, type) in param_list:	# will generate like this (FILE(string))(LINE(string))
			param_list_string = param_list_string + '(' + str(var) + ',(' + str(type) + ')' + ')'
		cog.outl('BOOST_PARAMETER_MEMBER_FUNCTION( (void), %s, tag, (required (program_node, (tree::Program&))(node, (tree::ASTNode&)) %s )) {' % (id, param_list_string))

		# Variable declaration
		cog.outl('\t map<wstring, wstring> parameters;')
		cog.outl('\t wstring str_level(L"%s");' % attribute_table[id][0])
		cog.outl('\t wstring str_id(L"%s");' % id)

		# Generate the implementation
		cog.outl('\t wstring translated = get_translated(StringTable::%s);' % id)

		for (var, type) in param_list:
			to_search = str('$') + str(var) + '(' + str(type) + ')'
			cog.outl('\t substitute(translated, L"%s", %s);' % (to_search, var))
			cog.outl('\t insert_parameters(parameters, L"%s", %s);' % (var.lower(), var))

		cog.outl('\t LogInfoContext::set(&node, new LogInfoContext(str_level, str_id, parameters));')

		# Generate header like : "test.cpp:32: "
		cog.outl('\t vector<string>& files = stage::ModuleSourceInfoContext::get(&program_node)->source_files;')
		cog.outl('\t stage::SourceInfoContext* source_info = stage::SourceInfoContext::get(&node);')

		cog.outl('\t mWrapper->log(StringTable::%s, s_to_ws(files[source_info->source_index]), source_info->line, translated);' % id)
		cog.outl('}');
	]]]*/
	//[[[end]]]

private:
	wstring get_translated(StringTable::log_id id)
	{
		string locale_name = get_lc_message();

		BOOST_ASSERT(mStringTable->translation_table.find(id) != mStringTable->translation_table.end() && "Unknown Log Id");

		StringTable::locale_translate_map_t& translate_map = mStringTable->translation_table[id];
		if (translate_map.find(locale_name) == translate_map.end())
		{
			// use default -- en_US
			locale_name = "en_US";
		}
		return translate_map[locale_name];
	}

	string get_lc_message()
	{
		string lc_all = mLocale.name();
		vector<string> locale_categories = StringUtil::tokenize(lc_all, ";", false);

		for (int i = 0; i < locale_categories.size(); i++)
		{
			// We will have something like this: LC_MESSAGES, en_US.UTF-8
			vector<string> category = StringUtil::tokenize(locale_categories[i], "=", false);
			if (category.size() != 2) continue;
			if (category[0] != "LC_MESSAGES") continue;

			// Now we have lang_encoding = "en_US.UTF-8"
			string lang_encoding = category[1];

			// Strip out ".UTF-8", we only need "en_US"
			string lang = StringUtil::tokenize(lang_encoding, ".", false)[0];
			return lang;
		}

		return "en_US";
	}

	template <typename T>
	bool substitute(wstring &s, const wstring &to_search, const T &to_replace)
	{
		wstringstream stream;
		stream << to_replace;
		return substitute(s, to_search, stream.str());
	}

	bool substitute(wstring &s, const wstring &to_search, string &to_replace)
	{
		return substitute(s, to_search, s_to_ws(to_replace));
	}

	bool substitute(wstring &s, const wstring &to_search, const wstring &to_replace)
	{
		bool replace_found = false;
		wstring::size_type p = 0;
		while ((p = s.find(to_search, p)) != wstring::npos)
		{
			s.replace(p, to_search.size(), to_replace);
			p++;
			replace_found = true;
		}
		return replace_found;
	}

	template <typename T>
	void insert_parameters(map<wstring, wstring>& parameters, const wstring& key, const T& value)
	{
		wstringstream stream;
		stream << value;
		insert_parameters(parameters, key, stream.str());
	}

	void insert_parameters(map<wstring, wstring>& parameters, const wstring& key, const string& value)
	{
		insert_parameters(parameters, key, s_to_ws(value));
	}

	void insert_parameters(map<wstring, wstring>& parameters, const wstring& key, const wstring& value)
	{
		parameters[key] = value;
	}

private:
	LoggerWrapper* mWrapper;
	locale mLocale;
	StringTable* mStringTable;
};

}}

#endif /* ZILLIANS_LANGUAGE_STRINGTABLE_H_ */
